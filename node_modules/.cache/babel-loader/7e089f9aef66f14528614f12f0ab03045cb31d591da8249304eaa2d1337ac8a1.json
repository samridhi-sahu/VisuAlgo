{"ast":null,"code":"export const mergeSort = state => {\n  console.log(\"merge sort called\");\n  let history = [];\n  const arr = state.map(objarr => objarr);\n\n  // push intitial state\n  history.push(arr.map(obj => {\n    return {\n      ...obj\n    };\n  }));\n  let startIndex = 0;\n  let endIndex = arr.length - 1;\n\n  // history array is pass by reference by default\n  merge_sort(arr, startIndex, endIndex, history);\n\n  // make sorted element green\n  history.push(arr.map((obj, idx) => {\n    return {\n      ...obj,\n      color: \"#32CD32\"\n    };\n  }));\n  // make it default color\n  history.push(arr.map((obj, idx) => {\n    return {\n      ...obj\n    };\n  }));\n  return history;\n};\nfunction merge_sort(arr, startIndex, endIndex, history) {\n  if (startIndex < endIndex) {\n    let mid = Math.floor((startIndex + endIndex) / 2);\n    merge_sort(arr, startIndex, mid, history);\n    merge_sort(arr, mid + 1, endIndex, history);\n    merge(arr, startIndex, mid, endIndex, history);\n  }\n  return;\n}\nfunction merge(arr, startIndex, mid, endIndex, history) {\n  let leftArr = [];\n  // copy left sorted array\n  for (let i = startIndex; i <= mid; i++) {\n    leftArr.push({\n      ...arr[i]\n    });\n  }\n  // push int  max\n  leftArr.push({\n    value: 999999\n  });\n  let rightArr = [];\n  // copy right sorted array\n  for (let i = mid + 1; i <= endIndex; i++) {\n    rightArr.push({\n      ...arr[i]\n    });\n  }\n  //push in t max\n  rightArr.push({\n    value: 999999\n  });\n\n  /* make mid as red color  */\n  history.push(arr.map((obj, idx) => {\n    if (idx === mid) {\n      return {\n        ...obj,\n        color: \"red\"\n      };\n    } else if (idx >= startIndex && idx <= endIndex) {\n      return {\n        ...obj,\n        color: \"green\"\n      };\n    }\n    return {\n      ...obj\n    };\n  }));\n  let i = 0,\n    j = 0,\n    index = startIndex;\n  while (index <= endIndex) {\n    if (leftArr[i].value <= rightArr[j].value) {\n      arr[index++] = leftArr[i++];\n    } else {\n      arr[index++] = rightArr[j++];\n    }\n  }\n\n  // make it default color\n  history.push(arr.map((obj, idx) => {\n    return {\n      ...obj\n    };\n  }));\n}","map":{"version":3,"names":["mergeSort","state","console","log","history","arr","map","objarr","push","obj","startIndex","endIndex","length","merge_sort","idx","color","mid","Math","floor","merge","leftArr","i","value","rightArr","j","index"],"sources":["C:/Users/SAMRIDHI SAHU/AppData/Roaming/nvm/v18.16.0/algorithm-visualizer/src/Algorithms/merge-sort.js"],"sourcesContent":["\r\nexport const mergeSort = (state) =>{\r\n    console.log(\"merge sort called\");\r\n    let history = [];\r\n    const arr = state.map((objarr) => objarr);\r\n\r\n    // push intitial state\r\n    history.push(\r\n        arr.map( obj => {\r\n            return {...obj}\r\n        })\r\n    );\r\n\r\n    let startIndex = 0;\r\n    let endIndex = arr.length -1;\r\n    \r\n\r\n    // history array is pass by reference by default\r\n    merge_sort(arr,startIndex, endIndex, history);\r\n\r\n\r\n\r\n\r\n\r\n     // make sorted element green\r\n    history.push(\r\n        arr.map((obj, idx)=>{\r\n                return {\r\n                    ...obj,\r\n                    color: \"#32CD32\"\r\n                }\r\n        })\r\n    );\r\n    // make it default color\r\n    history.push(\r\n        arr.map((obj, idx)=>{\r\n                return {\r\n                    ...obj\r\n                }\r\n        })\r\n    );\r\n\r\n\r\n    return history;\r\n}\r\n\r\n\r\nfunction merge_sort(arr, startIndex, endIndex, history){ \r\n    if(startIndex < endIndex){\r\n        let mid = Math.floor((startIndex + endIndex)/2);\r\n\r\n        merge_sort(arr, startIndex, mid, history);\r\n        merge_sort(arr, mid+1, endIndex, history);\r\n        merge(arr, startIndex, mid, endIndex, history);\r\n    }\r\n    return ;\r\n}\r\n\r\n\r\nfunction merge(arr, startIndex, mid, endIndex, history){\r\n    let leftArr = [];\r\n    // copy left sorted array\r\n    for(let i = startIndex; i<= mid ;i++){\r\n        leftArr.push({...arr[i]});\r\n    }\r\n    // push int  max\r\n    leftArr.push({value : 999999});\r\n\r\n    let rightArr = [];\r\n    // copy right sorted array\r\n    for( let i = mid+1 ; i<=endIndex ; i++){\r\n        rightArr.push({...arr[i]});\r\n    }\r\n    //push in t max\r\n    rightArr.push({value : 999999});\r\n\r\n    /* make mid as red color  */\r\n     history.push(\r\n        arr.map((obj, idx)=>{\r\n               if(idx === mid) {\r\n                   return {\r\n                       ...obj,\r\n                       color : \"red\"\r\n                   }\r\n               }else if (idx >= startIndex && idx <= endIndex){\r\n                   return {\r\n                        ...obj,\r\n                        color: \"green\"   \r\n                    }\r\n\r\n               }\r\n               return {...obj};\r\n                \r\n        })\r\n     );\r\n\r\n\r\n    let i = 0,\r\n        j = 0,\r\n        index = startIndex;\r\n\r\n    while( index<= endIndex){\r\n       \r\n\r\n        if(leftArr[i].value <= rightArr[j].value){\r\n            arr[index++] = leftArr[i++];\r\n        }else{\r\n             arr[index++] = rightArr[j++];\r\n        }\r\n    }   \r\n    \r\n    \r\n    // make it default color\r\n    history.push(\r\n        arr.map((obj, idx)=>{\r\n                return {\r\n                    ...obj\r\n                }\r\n        })\r\n    );\r\n\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}